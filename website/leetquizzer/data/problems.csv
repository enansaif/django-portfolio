number,name,topic,difficulty,solution,option1,option2,edge_case
2101,Detonate the Maximum Bombs,Graph,Medium,make a directional adjency list using distance between two nodes. do bfs on each node and track the max possible value.,make a directional adjency list using distance between two nodes. do bfs on each node and track the max possible value.,make a directional adjency list using distance between two nodes. do bfs on each node and track the max possible value.,make a directional adjency list using distance between two nodes. do bfs on each node and track the max possible value.
300,Longest Increasing Subsequence,DP / Subsequence,Medium,"memoization - stat at -1, loop forward, only do dfs for values that are greater (or i < 0), add 1","memoization - stat at -1, loop forward, only do dfs for values that are greater (or i < 0), add 1","memoization - stat at -1, loop forward, only do dfs for values that are greater (or i < 0), add 1","memoization - stat at -1, loop forward, only do dfs for values that are greater (or i < 0), add 1"
47,Permutations II,Backtracking,Medium,"get a count dict for keeping unique numbers in nums, make sure to take 1 number only once per level. decrement count","get a count dict for keeping unique numbers in nums, make sure to take 1 number only once per level. decrement count","get a count dict for keeping unique numbers in nums, make sure to take 1 number only once per level. decrement count","get a count dict for keeping unique numbers in nums, make sure to take 1 number only once per level. decrement count"
1288,Remove Covered Intervals,Intervals,Medium,"multiply -1 with every end point of intervals, sort. covering intervals will automatically be in front","multiply -1 with every end point of intervals, sort. covering intervals will automatically be in front","multiply -1 with every end point of intervals, sort. covering intervals will automatically be in front","multiply -1 with every end point of intervals, sort. covering intervals will automatically be in front"
912,Sort an Array,Sorting,Medium,different sorting algorithms,different sorting algorithms,different sorting algorithms,different sorting algorithms
1539,Kth Missing Positive Number,Binary Search,Easy,"find the last index where total missing < k, add how many more missing to its value ","find the last index where total missing < k, add how many more missing to its value ","find the last index where total missing < k, add how many more missing to its value ","find the last index where total missing < k, add how many more missing to its value "
1721,Swapping Nodes in a Linked List,Linked List,Medium,"1. navigate, swap values | 2. find prevLeft, left and prevRight, right. swap prevLeft, prevRight and left.next, right.next in pairs otherwise potential self loop for ...->left -> right->...","1. navigate, swap values | 2. find prevLeft, left and prevRight, right. swap prevLeft, prevRight and left.next, right.next in pairs otherwise potential self loop for ...->left -> right->...","1. navigate, swap values | 2. find prevLeft, left and prevRight, right. swap prevLeft, prevRight and left.next, right.next in pairs otherwise potential self loop for ...->left -> right->...","1. navigate, swap values | 2. find prevLeft, left and prevRight, right. swap prevLeft, prevRight and left.next, right.next in pairs otherwise potential self loop for ...->left -> right->..."
215,Kth Largest Element in an Array,Heap / Queue,Medium,"heapify or sort, iterate k times to get result","heapify or sort, iterate k times to get result","heapify or sort, iterate k times to get result","heapify or sort, iterate k times to get result"
338,Counting Bits,Bit Manipulation,Easy,"n log n = % 2, / 2 | O(64) = & 1, >> 1 ","n log n = % 2, / 2 | O(64) = & 1, >> 1 ","n log n = % 2, / 2 | O(64) = & 1, >> 1 ","n log n = % 2, / 2 | O(64) = & 1, >> 1 "
2439,Minimize Maximum of Array,Binary Search,Medium,"(nlogm) soln -> l = nums[0], r = max(nums), find if m can be distributed in the array                  (n) soln (Greedy) -> find the max value that can be distributed ","(nlogm) soln -> l = nums[0], r = max(nums), find if m can be distributed in the array                  (n) soln (Greedy) -> find the max value that can be distributed ","(nlogm) soln -> l = nums[0], r = max(nums), find if m can be distributed in the array                  (n) soln (Greedy) -> find the max value that can be distributed ","(nlogm) soln -> l = nums[0], r = max(nums), find if m can be distributed in the array                  (n) soln (Greedy) -> find the max value that can be distributed "
54,Spiral Matrix,Math & Geometry,Medium,"my soln -> add same direction to r, c, mark visited. if next dir out of bounds or visited, change dir nc slon -> keep track of left, right, top, bottom bound, when direction change, decrease bound","my soln -> add same direction to r, c, mark visited. if next dir out of bounds or visited, change dir nc slon -> keep track of left, right, top, bottom bound, when direction change, decrease bound","my soln -> add same direction to r, c, mark visited. if next dir out of bounds or visited, change dir nc slon -> keep track of left, right, top, bottom bound, when direction change, decrease bound","my soln -> add same direction to r, c, mark visited. if next dir out of bounds or visited, change dir nc slon -> keep track of left, right, top, bottom bound, when direction change, decrease bound"
1930,Unique Length-3 Palindromic Subsequences,Array & Hashing,Medium,"keep track of left and right element count, for each middle, if there are same chars in left and right, add it to result set. return the len of result","keep track of left and right element count, for each middle, if there are same chars in left and right, add it to result set. return the len of result","keep track of left and right element count, for each middle, if there are same chars in left and right, add it to result set. return the len of result","keep track of left and right element count, for each middle, if there are same chars in left and right, add it to result set. return the len of result"
355,Design Twitter,Heap / Queue,Medium,"keep tweets in tweet list keep all userId in followers dictionary of sets. each time iterate over all tweets, take tweets from followees or self","keep tweets in tweet list keep all userId in followers dictionary of sets. each time iterate over all tweets, take tweets from followees or self","keep tweets in tweet list keep all userId in followers dictionary of sets. each time iterate over all tweets, take tweets from followees or self","keep tweets in tweet list keep all userId in followers dictionary of sets. each time iterate over all tweets, take tweets from followees or self"
53,Maximum Subarray,DP / Greedy,Medium,"maintain a current sum, reset current sum if it gets below 0","maintain a current sum, reset current sum if it gets below 0","maintain a current sum, reset current sum if it gets below 0","maintain a current sum, reset current sum if it gets below 0"
152,Maximum Product Subarray,DP / Greedy,Medium,"keep track of previous maximum and minimum product, if n == 0, reset both to 1, else get curr max and min from max/min(both * n, n), compare with bestMax","keep track of previous maximum and minimum product, if n == 0, reset both to 1, else get curr max and min from max/min(both * n, n), compare with bestMax","keep track of previous maximum and minimum product, if n == 0, reset both to 1, else get curr max and min from max/min(both * n, n), compare with bestMax","keep track of previous maximum and minimum product, if n == 0, reset both to 1, else get curr max and min from max/min(both * n, n), compare with bestMax"